## [目录]

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

  - [[目录]](#目录)
- [根据组件进行误差分析](#根据组件进行误差分析)
- [误差归因至某个组件](#误差归因至某个组件)
- [误差归因的一般情况](#误差归因的一般情况)
- [组件误差分析与人类水平对比](#组件误差分析与人类水平对比)

<!-- /code_chunk_output -->

# 根据组件进行误差分析

**尝试将每一个算法造成的误差归因于流水线的某个组件**

我们使用暹罗猫分类器的例子来进行说明：

![](/images/伽罗猫.png)
在上图的流水线中，第一部分是猫检测器，它能够检测出猫，并将它们从图像裁剪出来；第二部分是猫的品种分类器，决定它是否是暹罗猫。 改进两个组件中的任何一个都有可能花费数年的时间。 你该决定关注哪个（些）组件呢？

如果你对 100 个误分类的开发集图像遍历检查，并发现 90 个误差可归因于猫探测器，并只有 10 个误差可归因于猫品种分类器。 那么你可以有把握地得出结论，应该更加专注于改进猫探测器。

# 误差归因至某个组件
确保在检测某个组件时，其输入是完美的。什么意思呢，还是拿猫举例：
- 检测猫咪检测器时，提供确定带猫的图片
- 检测猫咪种类分类器时，提供带猫的图片，且图片上标记好了猫的具体位置
![](/images/cat.png)

# 误差归因的一般情况
以下是误差归因的一般步骤。 假设在流水线中有三个步骤 A，B 和 C，其中 A 直接输出到 B，B直接输出到 C：
![](/images/一般情况.png)

对于系统在开发集上存在的每个错误样本：

1. 尝试人为修改 A 的输出为 “完美” 输出（例如，猫的“完美”边界框），并在此输出上运行流水线其余的 B，C 部分。 如果算法现在给出了正确的输出，那么这表明，只要 A 给出了更好的输出，那么整个算法的输出就是正确的；因此，你可以将此误差归因于组件 A. 否则，请继续执行步骤 2
2. 尝试人为修改 B 的输出为 “完美” 输出。如果算法现在给出正确的输出，则将误差归因于组 件 B. 否则，继续执行步骤 3
3. 将误差归因于组件 B

让我们来看一个复杂一点的例子：
![](/images/复杂例子.png)

将三个组件映射到 A, B, C，如下所示：
A：检测汽车 B：检测行人 C：规划汽车路径

按照上述程序，假设你在封闭的轨道上对你的汽车进行测试，发现汽车选择了一个比熟练司机更刺耳的转向方向。在自动驾驶领域，这种情况通常被称为​场景（scenario）。接着你需要：
1. 尝试人为修改 A （检测汽车）的输出，使之成为 “完美” 输出（例如，手动进入并告诉它其他汽车在哪里)。像之前一样运行流水线其余的 B，C 部分，但是允许 C （规划路径）使用 A 现在的完美输出。如果算法现在为汽车规划出一条更好的路径，那么这表明，如果 A 给出更好的输出，整个算法的输出会更好；因此，你可以将此误差归因于
组件 A. 否则，继续执行步骤 2
2. 尝试人为修改 B （检测行人）的输出，使之成为 “完美” 输出。如果算法现在给出了正确的输出，那么将误差归因为组件 B
3. 将误差归因于组件 C


**ML 流水线的组件应该按照有向无环图（DAG）排序**，这意味着你应该能够以某种固定的从左到右的顺序来计算它们，并且后面的组件应该只依赖于早期组件的输出。只要组件到A->B->C 顺序的映射遵循 DAG 顺序，那么误差分析就没问题。但如果你交换 A 和 B，可能会得到略微不同的结果：

A：检测行人（以前是检测汽车） B：检测汽车（以前是检测行人） C：规划汽车路径

但是这个分析的结果仍然是有效的，并且可以很好地指导你把注意力集中在哪里。

# 组件误差分析与人类水平对比
